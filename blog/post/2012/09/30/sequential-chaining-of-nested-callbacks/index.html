<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Sequential Chaining of Nested Callbacks</title>
    <link rel="stylesheet" href="/css/bootstrap.css">
    <link rel="stylesheet" href="/css/bootstrap-responsive.css">
    <script src="/js/bootstrap.js"></script>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <link rel="stylesheet" href="/css/common.css">
    <meta name="generator" content="nanoc 3.6.4">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/css/post.css">
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-40183531-1']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>
  <body>
    <div id="menu">
      <div><a href="/">Home</a></div><div><a href="/about/">About</a></div><div><a href="/blog/">Blog</a></div><div><a href="/code/">Code</a></div><div><a href="/blog/feed/">Feed</a></div>
    </div>
    

<div class="container">
  <div class="row-fluid">
    <div class="offset2 span8">
      <div id="post" class="more-white-box rounded-corners">
	<div class="head">
	  <div class="title">Sequential Chaining of Nested Callbacks</div>
	  <div class="subtitle">posted at
	    September 30, 2012
	    with tags <a href="/blog/tag/coffeescript">coffeescript</a>, <a href="/blog/tag/concurrency">concurrency</a>, <a href="/blog/tag/javascript">javascript</a>
	  </div>
	  <div class="share">
	    <div class="addthis_toolbox addthis_default_style ">
	      <a class="addthis_button_preferred_1"></a>
	      <a class="addthis_button_preferred_2"></a>
	      <a class="addthis_button_preferred_3"></a>
	      <a class="addthis_button_preferred_4"></a>
	      <a class="addthis_button_compact"></a>
	    </div>
	    <script type="text/javascript">var addthis_config = {"data_track_addressbar":false};</script>
	    <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5144adf75211a62b"></script>
	  </div>
	</div>
	<div class="body">

	  <p>Back in the old days of programming, the days we used to have blocking function calls, things were easy: <em>first</em> do this, and <em>then</em> do that, and <em>finally</em> clean things up. While this sequential style of programming has its own advantages in terms of human perception, it imposes certain concurrency related limitations. That is, each expression in a program is supposed to wait for the completion of the execution flow up until the line above, regardless of if it has anything to do with the current expression or not. Asynchronious programs are known to solve this problem of concurrency, (at least, to some extent) with the cost of sacrificing the sequential program flow. At its most basic form, functions are provided interfaces to specify dependencies between each other and hence, independent functions are allowed to execute concurrently. These interfaces are generally provided in the form of callback functions, that is, when <code>f()</code> gets completed do <code>g()</code>, and when <code>g()</code> completes do <code>h()</code>, and so on. The premise of this blog post is to investigate whether it is possible to still preserve the dependency between functions by still allowing the programmer to syntatically structure the program sequentially.</p>

<p><img src="seq-tran.png" alt="Sequential vs. Concurrent Program Flow"></p>

<p>In the context of asynchronious programming, JavaScript is an exceptional example, where almost every functionality in the language is shaped according to asynchronous callbacks, which eventually enforces you to program in a totally top-down callback-oriented style. In this post, I prefered to use CoffeeScript (which is a programming language compiled to JavaScript) to enhance the plain text the explanations.</p>

<p>Ok, enough talk. Let’s start with working on a small sequential program snippet.</p>

<pre><code class="language-coffeescript"><span class="k">try</span>
    <span class="nv">conn = </span><span class="nx">db</span><span class="p">.</span><span class="nx">open</span> <span class="s">"local"</span>
    <span class="nv">rows = </span><span class="nx">conn</span><span class="p">.</span><span class="nx">query</span> <span class="s">"SELECT key, val FROM entries"</span>
    <span class="nx">conn</span><span class="p">.</span><span class="nx">close</span><span class="p">()</span>
    <span class="nx">user</span><span class="p">.</span><span class="nx">send</span> <span class="nv">result: </span><span class="nx">rows</span>
<span class="k">catch</span> <span class="nx">err</span>
    <span class="nx">user</span><span class="p">.</span><span class="nx">send</span> <span class="nv">error: </span><span class="nx">err</span></code></pre>

<p>Simple and intuitive. You just grab the logic behind at first sight: <em>First</em>, connect to the database, and <em>then</em> query the rows of a table, and <em>finally</em> close the connection and return the results. And as a bonus you can catch errors that would occur during this sequence. Here is its asynchronious, callback-driven counterpart:</p>

<pre><code class="language-coffeescript"><span class="c1"># Erronous try-catch block. (db.open might have been completed and the</span>
<span class="c1"># catch block would be passed over.)</span>
<span class="k">try</span>
    <span class="nx">db</span><span class="p">.</span><span class="nx">open</span> <span class="s">"local"</span><span class="p">,</span> <span class="nf">(conn) -&gt;</span>
        <span class="nx">conn</span><span class="p">.</span><span class="nx">query</span> <span class="s">"SELECT key, val FROM entries"</span><span class="p">,</span> <span class="nf">(rows) -&gt;</span>
            <span class="nx">conn</span><span class="p">.</span><span class="nx">close</span><span class="p">()</span>
            <span class="nx">user</span><span class="p">.</span><span class="nx">send</span> <span class="nv">result: </span><span class="nx">rows</span>
<span class="k">catch</span> <span class="nx">err</span>
    <span class="nx">util</span><span class="p">.</span><span class="nx">log</span> <span class="nx">err</span>
    <span class="nx">user</span><span class="p">.</span><span class="nx">send</span> <span class="nv">error: </span><span class="nx">err</span></code></pre>

<p>Um… Not as intiutive as its sequential counterpart. And the nested callback chains expands the code to the right, which makes it harder to understand as well. But, not that bad… with a serious glitch: Orphan exceptions. That is, for instance, who is supposed to catch a <code>connection error</code> exception after <code>db.open</code> completes gracefully and the execution passes over the try-catch block? While code will be get polluted a little bit, this problem can be tackled by returning an error, instead of raising an exception.</p>

<pre><code class="language-coffeescript"><span class="nx">db</span><span class="p">.</span><span class="nx">open</span> <span class="s">"local"</span><span class="p">,</span> <span class="nf">(err, conn) -&gt;</span>
    <span class="k">return</span> <span class="nx">user</span><span class="p">.</span><span class="nx">send</span> <span class="nv">error: </span><span class="s">"connection error: </span><span class="si">#{</span><span class="nx">err</span><span class="si">}</span><span class="s">"</span> <span class="k">if</span> <span class="nx">err</span><span class="o">?</span>
    <span class="nx">conn</span><span class="p">.</span><span class="nx">query</span> <span class="s">"SELECT key, val FROM entries"</span><span class="p">,</span> <span class="nf">(err, rows) -&gt;</span>
        <span class="nx">conn</span><span class="p">.</span><span class="nx">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="nx">user</span><span class="p">.</span><span class="nx">send</span> <span class="nv">error: </span><span class="s">"query error: </span><span class="si">#{</span><span class="nx">err</span><span class="si">}</span><span class="s">"</span> <span class="k">if</span> <span class="nx">err</span><span class="o">?</span>
        <span class="nx">user</span><span class="p">.</span><span class="nx">send</span> <span class="nv">result: </span><span class="nx">rows</span></code></pre>

<p>Better now, at least in terms of correctness.</p>

<p>So far, we always beforehand knew the callbacks that will be nested into each other. That is, we knew that a simple query will follow just after the database connection gets established. What if we wouldn’t? What if the next callback is to be dynamically determined according to a runtime variable? Think about this scenario: You need to query the database multiple times depending on the input passed by the user. A pretty common day-to-day practice. Terrorizing the code with unknown number of nested callbacks would buy us no credits.</p>

<pre><code class="language-coffeescript"><span class="nv">ids = </span><span class="p">[...]</span> <span class="c1"># The user provided input.</span>

<span class="nv">totalRows = </span><span class="p">[]</span>
<span class="nx">db</span><span class="p">.</span><span class="nx">open</span> <span class="s">"local"</span><span class="p">,</span> <span class="nf">(err, conn) -&gt;</span>
    <span class="k">return</span> <span class="nx">user</span><span class="p">.</span><span class="nx">send</span> <span class="nv">error: </span><span class="s">"connection error: </span><span class="si">#{</span><span class="nx">err</span><span class="si">}</span><span class="s">"</span> <span class="k">if</span> <span class="nx">err</span><span class="o">?</span>
    <span class="nv">id = </span><span class="nx">ids</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
    <span class="k">return</span> <span class="nx">conn</span><span class="p">.</span><span class="nx">close</span><span class="p">()</span> <span class="k">unless</span> <span class="nx">id</span><span class="o">?</span>
    <span class="nx">conn</span><span class="p">.</span><span class="nx">query</span> <span class="s">"SELECT key, val FROM entries WHERE id = </span><span class="si">#{</span><span class="nx">id</span><span class="si">}</span><span class="s">"</span><span class="p">,</span> <span class="nf">(err, rows) -&gt;</span>
        <span class="k">if</span> <span class="nx">err</span><span class="o">?</span>
            <span class="nx">conn</span><span class="p">.</span><span class="nx">close</span><span class="p">()</span>
            <span class="k">return</span> <span class="nx">user</span><span class="p">.</span><span class="nx">send</span> <span class="nv">error: </span><span class="s">"query error: </span><span class="si">#{</span><span class="nx">err</span><span class="si">}</span><span class="s">"</span>
        <span class="nx">totalRows</span> <span class="o">+=</span> <span class="nx">rows</span>
        <span class="nv">id = </span><span class="nx">ids</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
        <span class="k">return</span> <span class="nx">conn</span><span class="p">.</span><span class="nx">close</span><span class="p">()</span> <span class="k">unless</span> <span class="nx">id</span><span class="o">?</span>
        <span class="nx">conn</span><span class="p">.</span><span class="nx">query</span> <span class="s">"SELECT key, val FROM entries WHERE id = </span><span class="si">#{</span><span class="nx">id</span><span class="si">}</span><span class="s">"</span><span class="p">,</span> <span class="nf">(err, rows) -&gt;</span>
            <span class="k">if</span> <span class="nx">err</span><span class="o">?</span>
                <span class="nx">conn</span><span class="p">.</span><span class="nx">close</span><span class="p">()</span>
                <span class="k">return</span> <span class="nx">user</span><span class="p">.</span><span class="nx">send</span> <span class="nv">error: </span><span class="s">"query error: </span><span class="si">#{</span><span class="nx">err</span><span class="si">}</span><span class="s">"</span>
            <span class="nx">totalRows</span> <span class="o">+=</span> <span class="nx">rows</span>
            <span class="nv">id = </span><span class="nx">ids</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
            <span class="k">return</span> <span class="nx">conn</span><span class="p">.</span><span class="nx">close</span><span class="p">()</span> <span class="k">unless</span> <span class="nx">id</span><span class="o">?</span>
            <span class="nx">conn</span><span class="p">.</span><span class="nx">query</span> <span class="s">"SELECT key, val FROM entries WHERE id = </span><span class="si">#{</span><span class="nx">id</span><span class="si">}</span><span class="s">"</span><span class="p">,</span> <span class="nf">(err, rows) -&gt;</span>
                <span class="k">if</span> <span class="nx">err</span><span class="o">?</span>
                    <span class="nx">conn</span><span class="p">.</span><span class="nx">close</span><span class="p">()</span>
                    <span class="k">return</span> <span class="nx">user</span><span class="p">.</span><span class="nx">send</span> <span class="nv">error: </span><span class="s">"query error: </span><span class="si">#{</span><span class="nx">err</span><span class="si">}</span><span class="s">"</span>
                <span class="nx">totalRows</span> <span class="o">+=</span> <span class="nx">rows</span>
                <span class="c1"># ...</span></code></pre>

<p>On the other hand, forming nested callbacks using a recursive function solves the problem.</p>

<pre><code class="language-coffeescript"><span class="nv">ids = </span><span class="p">[...]</span> <span class="c1"># The user provided input.</span>

<span class="nx">db</span><span class="p">.</span><span class="nx">open</span> <span class="s">"local"</span><span class="p">,</span> <span class="nf">(err, conn) -&gt;</span>
    <span class="k">return</span> <span class="nx">user</span><span class="p">.</span><span class="nx">send</span> <span class="nv">error: </span><span class="s">"connection error: </span><span class="si">#{</span><span class="nx">err</span><span class="si">}</span><span class="s">"</span> <span class="k">if</span> <span class="nx">err</span><span class="o">?</span>
    <span class="nv">f = </span><span class="nf">(accum) -&gt;</span>
        <span class="nv">id = </span><span class="nx">ids</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="o">not</span> <span class="nx">id</span><span class="o">?</span>
            <span class="nx">conn</span><span class="p">.</span><span class="nx">close</span><span class="p">()</span>
            <span class="k">return</span> <span class="nx">accum</span>
        <span class="nx">conn</span><span class="p">.</span><span class="nx">query</span> <span class="s">"SELECT key, val FROM entries WHERE id = </span><span class="si">#{</span><span class="nx">id</span><span class="si">}</span><span class="s">"</span><span class="p">,</span> <span class="nf">(err, rows) -&gt;</span>
            <span class="k">if</span> <span class="nx">err</span><span class="o">?</span>
                <span class="nx">conn</span><span class="p">.</span><span class="nx">close</span><span class="p">()</span>
                <span class="k">return</span> <span class="nx">user</span><span class="p">.</span><span class="nx">send</span> <span class="nv">error: </span><span class="s">"query error: </span><span class="si">#{</span><span class="nx">err</span><span class="si">}</span><span class="s">"</span>
            <span class="nx">f</span> <span class="nx">accum</span> <span class="o">+</span> <span class="nx">rows</span>
    <span class="nx">f</span> <span class="p">[]</span></code></pre>

<p>I admit that this is not intuitive, also more error-prone. (I also could not be sure if I wrote it right. But anyway, you get the idea.) There must be some other way. Wouldn’t it be cute if there would exist some sort of <em>sequencer</em> mechanism that allows me to sequentially chain my nested callbacks?</p>

<p><img src="yo-dawg.png" alt="Yo dawg!"></p>

<p>This <em>Aha!</em> moment helped me to come up with below tiny helper class.</p>

<pre><code class="language-coffeescript"><span class="k">class</span> <span class="nx">SequentialExecutor</span>
    <span class="nv">tasks: </span><span class="p">[]</span>
    <span class="nv">pos: </span><span class="mi">0</span>
    <span class="nv">add: </span><span class="nf">(task) =&gt;</span> <span class="nx">@tasks</span><span class="p">.</span><span class="nx">push</span> <span class="o">=&gt;</span> <span class="nx">task</span> <span class="o">=&gt;</span> <span class="nx">@run</span><span class="p">()</span>
    <span class="nv">run: </span><span class="o">=&gt;</span> <span class="nx">@tasks</span><span class="p">[</span><span class="nx">@pos</span><span class="o">++</span><span class="p">]()</span></code></pre>

<p><code>SequentialExecutor</code> helps you to push your functions into an array and executes them in order for you. Specifically, it passes you the pointer to the next function (i.e., <code>next</code>) that is supposed to be executed after current function. So, it is up to you to execute it or not. Here is an example using this cute <code>SequentialExecutor</code> class:</p>

<pre><code class="language-coffeescript"><span class="nv">exec = </span><span class="k">new</span> <span class="nx">SequentialExecutor</span><span class="p">()</span>

<span class="nx">exec</span><span class="p">.</span><span class="nx">add</span> <span class="nf">(next) -&gt;</span>
    <span class="nx">db</span><span class="p">.</span><span class="nx">open</span> <span class="s">"local"</span><span class="p">,</span> <span class="nf">(err, conn) -&gt;</span>
        <span class="k">return</span> <span class="nx">user</span><span class="p">.</span><span class="nx">send</span> <span class="nv">error: </span><span class="s">"connection error: </span><span class="si">#{</span><span class="nx">err</span><span class="si">}</span><span class="s">"</span> <span class="k">if</span> <span class="nx">err</span><span class="o">?</span>
        <span class="nv">exec.conn = </span><span class="nx">conn</span>
        <span class="nx">next</span><span class="p">()</span>

<span class="nx">exec</span><span class="p">.</span><span class="nx">add</span> <span class="nf">(next) -&gt;</span>
    <span class="nx">exec</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nx">query</span> <span class="s">"SELECT key, val FROM entries"</span><span class="p">,</span> <span class="nf">(err, rows) -&gt;</span>
        <span class="k">return</span> <span class="nx">user</span><span class="p">.</span><span class="nx">send</span> <span class="nv">error: </span><span class="s">"query error: </span><span class="si">#{</span><span class="nx">err</span><span class="si">}</span><span class="s">"</span> <span class="k">if</span> <span class="nx">err</span><span class="o">?</span>
        <span class="nx">user</span><span class="p">.</span><span class="nx">send</span> <span class="nv">result: </span><span class="nx">rows</span>
        <span class="nx">next</span><span class="p">()</span>

<span class="nx">exec</span><span class="p">.</span><span class="nx">add</span> <span class="nf">(next) -&gt;</span>
    <span class="nx">exec</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nx">close</span><span class="p">()</span>

<span class="nx">exec</span><span class="p">.</span><span class="nx">run</span><span class="p">()</span></code></pre>

<p>Yes, now we have something! Let’s also try to implement the case where the total number of queries are dynamically determined on the run.</p>

<pre><code class="language-coffeescript"><span class="nv">exec = </span><span class="k">new</span> <span class="nx">SequentialExecutor</span><span class="p">()</span>

<span class="nx">exec</span><span class="p">.</span><span class="nx">add</span> <span class="nf">(next) -&gt;</span>
    <span class="nx">db</span><span class="p">.</span><span class="nx">open</span> <span class="s">"local"</span><span class="p">,</span> <span class="nf">(err, conn) -&gt;</span>
        <span class="k">return</span> <span class="nx">user</span><span class="p">.</span><span class="nx">send</span> <span class="nv">error: </span><span class="s">"connection error: </span><span class="si">#{</span><span class="nx">err</span><span class="si">}</span><span class="s">"</span> <span class="k">if</span> <span class="nx">err</span><span class="o">?</span>
        <span class="nv">exec.conn = </span><span class="nx">conn</span>
        <span class="nx">next</span><span class="p">()</span>

<span class="nx">exec</span><span class="p">.</span><span class="nx">add</span> <span class="nf">(next) -&gt;</span>
    <span class="nx">exec</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nx">query</span> <span class="s">"SELECT key, val FROM entries"</span><span class="p">,</span> <span class="nf">(err, rows) -&gt;</span>
        <span class="k">return</span> <span class="nx">user</span><span class="p">.</span><span class="nx">send</span> <span class="nv">error: </span><span class="s">"query error: </span><span class="si">#{</span><span class="nx">err</span><span class="si">}</span><span class="s">"</span> <span class="k">if</span> <span class="nx">err</span><span class="o">?</span>

        <span class="c1"># Errounous dynamic task creation. exec.conn.close() will be evaluated</span>
        <span class="c1"># earlier then the insert tasks created within this task.</span>
        <span class="k">for</span> <span class="nx">row</span> <span class="k">in</span> <span class="nx">rows</span>
            <span class="nx">exec</span><span class="p">.</span><span class="nx">add</span> <span class="nf">(next) -&gt;</span>
                <span class="nx">exec</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nx">insert</span> <span class="nv">key: </span><span class="nx">row</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nv">val: </span><span class="nx">row</span><span class="p">.</span><span class="nx">val</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="nf">(err) -&gt;</span>
                    <span class="k">return</span> <span class="nx">user</span><span class="p">.</span><span class="nx">send</span> <span class="nv">error: </span><span class="s">"insert error: </span><span class="si">#{</span><span class="nx">err</span><span class="si">}</span><span class="s">"</span> <span class="k">if</span> <span class="nx">err</span><span class="o">?</span>
                    <span class="nx">next</span><span class="p">()</span>
        <span class="nx">exec</span><span class="p">.</span><span class="nx">add</span> <span class="nf">(next) -&gt;</span>
            <span class="nx">user</span><span class="p">.</span><span class="nx">send</span>
            <span class="nx">next</span><span class="p">()</span>

        <span class="nx">next</span><span class="p">()</span>

<span class="nx">exec</span><span class="p">.</span><span class="nx">add</span> <span class="nf">(next) -&gt;</span>
    <span class="nx">exec</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nx">close</span><span class="p">()</span>

<span class="nx">exec</span><span class="p">.</span><span class="nx">run</span><span class="p">()</span>

<span class="cm">###</span>
<span class="cm">Step | Command</span>
<span class="cm">-----+------------------</span>
<span class="cm">  1  | db.open</span>
<span class="cm">  2  | exec.conn.query</span>
<span class="cm">  3  | exec.conn.close (BOOM!)</span>
<span class="cm">  4  | exec.conn.insert</span>
<span class="cm">  5  | exec.conn.insert</span>
<span class="cm"> ...</span>
<span class="cm"> n-1 | exec.conn.insert</span>
<span class="cm">  n  | user_send</span>
<span class="cm">###</span></code></pre>

<p>Oops! That is not what we were expecting. Database connection is supposed to be closed at the end of the execution flow. Hrm… Can’t we enhance <code>SequentialExecutor</code> to label tasks with priorities? Here is the poor man’s sequential executor with priority support.</p>

<pre><code class="language-coffeescript"><span class="nv">Heap = </span><span class="nx">require</span><span class="p">(</span><span class="s">"heap"</span><span class="p">)</span>

<span class="k">class</span> <span class="nx">SequentialExecutor</span>
	<span class="nv">tasks: </span><span class="k">new</span> <span class="nx">Heap</span><span class="p">(</span><span class="nf">(u, v) -&gt;</span> <span class="nx">u</span><span class="p">.</span><span class="nx">rank</span> <span class="o">-</span> <span class="nx">v</span><span class="p">.</span><span class="nx">rank</span><span class="p">)</span>
	<span class="nv">add: </span><span class="nf">(rank, task) =&gt;</span> <span class="nx">@tasks</span><span class="p">.</span><span class="nx">push</span> <span class="nv">rank: </span><span class="nx">rank</span><span class="p">,</span> <span class="nv">task: </span><span class="o">=&gt;</span> <span class="nx">task</span> <span class="o">=&gt;</span> <span class="nx">@run</span><span class="p">()</span>
	<span class="nv">run: </span><span class="o">=&gt;</span> <span class="nx">@tasks</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span><span class="o">?</span><span class="p">.</span><span class="nx">task</span><span class="p">()</span></code></pre>

<p>Let’s give our new gear, <code>PrioritizedSequentialExecutor</code>, a try.</p>

<pre><code class="language-coffeescript"><span class="nv">exec = </span><span class="k">new</span> <span class="nx">PrioritizedSequentialExecutor</span><span class="p">()</span>

<span class="nx">exec</span><span class="p">.</span><span class="nx">add</span> <span class="mi">0</span><span class="p">,</span> <span class="nf">(next) -&gt;</span>
    <span class="nx">db</span><span class="p">.</span><span class="nx">open</span> <span class="s">"local"</span><span class="p">,</span> <span class="nf">(err, conn) -&gt;</span>
        <span class="k">return</span> <span class="nx">user</span><span class="p">.</span><span class="nx">send</span> <span class="nv">error: </span><span class="s">"connection error: </span><span class="si">#{</span><span class="nx">err</span><span class="si">}</span><span class="s">"</span> <span class="k">if</span> <span class="nx">err</span><span class="o">?</span>
        <span class="nv">exec.conn = </span><span class="nx">conn</span>
        <span class="nx">next</span><span class="p">()</span>

<span class="nx">exec</span><span class="p">.</span><span class="nx">add</span> <span class="mi">1</span><span class="p">,</span> <span class="nf">(next) -&gt;</span>
    <span class="nx">exec</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nx">query</span> <span class="s">"SELECT key, val FROM entries"</span><span class="p">,</span> <span class="nf">(err, rows) -&gt;</span>
        <span class="k">return</span> <span class="nx">user</span><span class="p">.</span><span class="nx">send</span> <span class="nv">error: </span><span class="s">"query error: </span><span class="si">#{</span><span class="nx">err</span><span class="si">}</span><span class="s">"</span> <span class="k">if</span> <span class="nx">err</span><span class="o">?</span>

        <span class="c1"># Errounous dynamic task creation. exec.conn.close() will be evaluated</span>
        <span class="c1"># earlier then the insert tasks created within this task.</span>
        <span class="k">for</span> <span class="nx">row</span> <span class="k">in</span> <span class="nx">rows</span>
            <span class="nx">exec</span><span class="p">.</span><span class="nx">add</span> <span class="mi">2</span><span class="p">,</span> <span class="nf">(next) -&gt;</span>
                <span class="nx">exec</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nx">insert</span> <span class="nv">key: </span><span class="nx">row</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span> <span class="nv">val: </span><span class="nx">row</span><span class="p">.</span><span class="nx">val</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="nf">(err) -&gt;</span>
                    <span class="k">return</span> <span class="nx">user</span><span class="p">.</span><span class="nx">send</span> <span class="nv">error: </span><span class="s">"insert error: </span><span class="si">#{</span><span class="nx">err</span><span class="si">}</span><span class="s">"</span> <span class="k">if</span> <span class="nx">err</span><span class="o">?</span>
                    <span class="nx">next</span><span class="p">()</span>
        <span class="nx">exec</span><span class="p">.</span><span class="nx">add</span> <span class="mi">4</span><span class="p">,</span> <span class="nf">(next) -&gt;</span>
            <span class="nx">user_send</span>
            <span class="nx">next</span><span class="p">()</span>

        <span class="nx">next</span><span class="p">()</span>

<span class="nx">exec</span><span class="p">.</span><span class="nx">add</span> <span class="mi">3</span><span class="p">,</span> <span class="nf">(next) -&gt;</span>
    <span class="nx">exec</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nx">close</span><span class="p">()</span>

<span class="nx">exec</span><span class="p">.</span><span class="nx">run</span><span class="p">()</span>

<span class="cm">###</span>
<span class="cm">Step | Command          | Priority</span>
<span class="cm">-----+------------------+---------</span>
<span class="cm">  1  | db.open          | 0</span>
<span class="cm">  2  | exec.conn.query  | 1</span>
<span class="cm">  3  | exec.conn.insert | 2</span>
<span class="cm">  4  | exec.conn.insert | 2</span>
<span class="cm"> ...</span>
<span class="cm"> n-2 | exec.conn.insert | 2</span>
<span class="cm"> n-1 | exec.conn.close  | 3</span>
<span class="cm">  n  | user_send        | 4</span>
<span class="cm">###</span></code></pre>

<p>Mission accomplished! Now we have a fully-fledged sequencer where we can dynamically push tasks with different priorities.</p>

<p>Note that while <code>PrioritizedSequentialExecutor</code> is quite good at doing what it is advertised for, especially compared to the lines of code written, there exists other libraries (e.g., <a href="https://github.com/substack/node-seq">seq</a>, <a href="https://github.com/substack/node-chainsaw">chainsaw</a>, <a href="https://github.com/coolaj86/futures">futures</a>, <a href="https://github.com/caolan/async">async</a>, <a href="https://github.com/JeffreyZhao/wind">windjs</a>, <a href="https://github.com/Sage/streamlinejs">streamlinejs</a>, etc.) with similar flow-control purposes. While you are at it, you might want to check them out too.</p>

	  <script type="text/javascript">
	    $("#post table").attr("class", "table table-hover");
	  </script>

	  <div id="disqus_thread"></div>
	  <script type="text/javascript">
	  var disqus_shortname = 'vyazici';
	  var disqus_identifier = '/blog/post/20120930-sequential-chaining-of-nested-callbacks/';
	  var disqus_title = 'Sequential Chaining of Nested Callbacks';
	  (function() {
	  	var dsq = document.createElement('script');
	  	dsq.type = 'text/javascript';
	  	dsq.async = true;
	  	dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
	  	(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
	  </script>

	</div>
      </div>
      <div id="bgauthor" class="narrow-font">
	background image by
	<a href="http://jenniferwetzel.com/">Jennifer Wetzel</a>
      </div>
    </div>
  </div>
</div>






  </body>
</html>

