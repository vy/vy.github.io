<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Enforcing a Locking Context on Variables in Scala</title>
    <link rel="stylesheet" href="/css/common.css">
    <meta name="generator" content="nanoc 3.8.0">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/css/post.css">
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-40183531-1']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>
  <body>
    <div id="container">

      <ul id="menu">
        <li><a href="/">Home</a></li><li><a href="/blog/">Blog</a></li><li><a href="/code/">Code</a></li><li><a href="/blog/feed/">Feed</a></li>
      </ul>

    


<div id="post">

	<div class="head">
		<div class="title">Enforcing a Locking Context on Variables in Scala</div>
		<div class="subtitle">posted at
			September 9, 2015
			with tags <a href="/blog/tag/concurrency">concurrency</a>, <a href="/blog/tag/scala">scala</a>
		</div>
	</div>

	<div class="body">

	  
<p>Accessing variables that need synchronization necessitates book keeping by
programmers. Since it is not something explicitly enforced by the language
mechanics, programmer needs to make sure that such variables are not accessed
out of a synchronization scope. Consider the following innocent user store:</p>

<pre><code class="language-scala"><span class="k">case</span> <span class="k">class</span> <span class="nc">User</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">manager</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span>

<span class="c1">// Use with caution! Can be accessed by multiple threads.</span>
<span class="k">private</span> <span class="k">var</span> <span class="n">users</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">User</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">User</span><span class="o">]()</span></code></pre>

<p>The safest approach would be encapsulating every access to <code>users</code> variables
in a <code>synchronized</code> block:</p>

<pre><code class="language-scala"><span class="k">def</span> <span class="n">save</span><span class="o">(</span><span class="n">user</span><span class="k">:</span> <span class="kt">User</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">synchronized</span> <span class="o">{</span> <span class="n">users</span> <span class="o">+=</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span> <span class="o">-&gt;</span> <span class="n">user</span> <span class="o">}</span>

<span class="k">def</span> <span class="n">findById</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">User</span><span class="o">]</span> <span class="k">=</span> <span class="n">synchronized</span> <span class="o">{</span> <span class="n">users</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="o">}</span></code></pre>

<p>You can even go further and use a <code>ReadWriteLock</code> to boost read-only queries:</p>

<pre><code class="language-scala"><span class="k">private</span> <span class="k">val</span> <span class="n">lock</span><span class="k">:</span> <span class="kt">ReadWriteLock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReentrantReadWriteLock</span><span class="o">()</span>

<span class="k">def</span> <span class="n">save</span><span class="o">(</span><span class="n">user</span><span class="k">:</span> <span class="kt">User</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">lock</span><span class="o">.</span><span class="n">writeLock</span><span class="o">().</span><span class="n">lock</span><span class="o">()</span>
  <span class="k">try</span> <span class="o">{</span> <span class="n">users</span> <span class="o">+=</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span> <span class="o">-&gt;</span> <span class="n">user</span> <span class="o">}</span>
  <span class="k">finally</span> <span class="o">{</span> <span class="n">lock</span><span class="o">.</span><span class="n">writeLock</span><span class="o">().</span><span class="n">unlock</span><span class="o">()</span> <span class="o">}</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">findById</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">User</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">lock</span><span class="o">.</span><span class="n">readLock</span><span class="o">().</span><span class="n">lock</span><span class="o">()</span>
  <span class="k">try</span> <span class="o">{</span> <span class="n">users</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="o">}</span>
  <span class="k">finally</span> <span class="o">{</span> <span class="n">lock</span><span class="o">.</span><span class="n">readLock</span><span class="o">().</span><span class="n">unlock</span><span class="o">()</span> <span class="o">}</span>
<span class="o">}</span></code></pre>

<p>Now you think you are safe. And it does not take a couple of VCS commits for
somebody (most probably you) to mess up the entire synchronization scheme:</p>

<pre><code class="language-scala"><span class="c1">// Violating thread-safety on `users`.</span>
<span class="k">override</span> <span class="k">def</span> <span class="n">toString</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">s</span><span class="s">"There are ${users.size} user(s)."</span></code></pre>

<p>Oops! There can arise a lot more complicated subtle bugs. Shit can even hit
the fan when you introduce multiple variables or make nested calls, that is,
functions calling functions calling functions which are accessing <code>users</code>. It
is obvious that you are doomed. Now good luck with your chasing the
<a href="https://en.wikipedia.org/wiki/Heisenbug">Heisenbug</a> journey!</p>

<p>Then it occured to me, canâ€™t we make the compiler enforce a certain lock
context while accessing to a particular set of variables? What if compiler
would not allow you to read <code>users</code> if your thread did not already acquire
<code>lock.readLock()</code>? Or similarly would not allow you to mutate it if you did
not already acquire <code>lock.writeLock()</code>? Here is the solution that I came up
with to these questions:</p>

<pre><code class="language-scala"><span class="k">import</span> <span class="nn">java.util.concurrent.locks.Lock</span>
<span class="k">import</span> <span class="nn">java.util.concurrent.locks.ReentrantReadWriteLock</span>

<span class="k">trait</span> <span class="nc">SynchronizedAccess</span> <span class="o">{</span>

  <span class="k">import</span> <span class="nn">SynchronizedAccess._</span>

  <span class="k">protected</span> <span class="k">val</span> <span class="n">instanceLock</span><span class="k">:</span> <span class="kt">ReentrantReadWriteLock</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">ReentrantReadWriteLock</span><span class="o">()</span>

  <span class="k">protected</span> <span class="k">val</span> <span class="n">instanceReadLock</span><span class="k">:</span> <span class="kt">ReadLock</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">ReadLock</span><span class="o">(</span><span class="n">instanceLock</span><span class="o">.</span><span class="n">readLock</span><span class="o">())</span>

  <span class="k">protected</span> <span class="k">val</span> <span class="n">instanceReadWriteLock</span><span class="k">:</span> <span class="kt">ReadWriteLock</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">ReadWriteLock</span><span class="o">(</span><span class="n">instanceLock</span><span class="o">.</span><span class="n">readLock</span><span class="o">(),</span> <span class="n">instanceLock</span><span class="o">.</span><span class="n">writeLock</span><span class="o">())</span>

  <span class="k">protected</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Synchronized</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="k">private</span> <span class="k">var</span> <span class="n">value</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="o">{</span>

    <span class="k">def</span> <span class="n">apply</span><span class="o">()(</span><span class="k">implicit</span> <span class="n">readLock</span><span class="k">:</span> <span class="kt">ReadLock</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
      <span class="n">validateLock</span><span class="o">(</span><span class="n">readLock</span><span class="o">,</span> <span class="n">instanceReadLock</span><span class="o">,</span> <span class="n">instanceReadWriteLock</span><span class="o">)</span>
      <span class="n">value</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="n">update</span><span class="o">(</span><span class="n">newValue</span><span class="k">:</span> <span class="kt">T</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">readWriteLock</span><span class="k">:</span> <span class="kt">ReadWriteLock</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
      <span class="n">validateLock</span><span class="o">(</span><span class="n">readWriteLock</span><span class="o">,</span> <span class="n">instanceReadWriteLock</span><span class="o">)</span>
      <span class="n">value</span> <span class="k">=</span> <span class="n">newValue</span>
    <span class="o">}</span>

    <span class="k">private</span> <span class="k">def</span> <span class="n">validateLock</span><span class="o">(</span><span class="n">lock</span><span class="k">:</span> <span class="kt">TypedLock</span><span class="o">,</span> <span class="n">allowedLocks</span><span class="k">:</span> <span class="kt">TypedLock*</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
      <span class="n">require</span><span class="o">(</span><span class="n">allowedLocks</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">lock</span><span class="o">),</span> <span class="s">"cannot be accessed from another synchronization scope"</span><span class="o">)</span>
      <span class="n">require</span><span class="o">(</span><span class="n">lock</span><span class="o">.</span><span class="n">tryLock</span><span class="o">(),</span> <span class="s">"cannot be accessed out of a synchronization scope"</span><span class="o">)</span>
      <span class="n">lock</span><span class="o">.</span><span class="n">unlock</span><span class="o">()</span>
    <span class="o">}</span>

  <span class="o">}</span>

  <span class="k">protected</span> <span class="k">def</span> <span class="n">synchronizeRead</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">body</span><span class="k">:</span> <span class="kt">ReadLock</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
    <span class="n">synchronizeOperation</span><span class="o">(</span><span class="n">instanceReadLock</span><span class="o">)(</span><span class="n">body</span><span class="o">)</span>

  <span class="k">protected</span> <span class="k">def</span> <span class="n">synchronizeReadWrite</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">body</span><span class="k">:</span> <span class="kt">ReadWriteLock</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
    <span class="n">synchronizeOperation</span><span class="o">(</span><span class="n">instanceReadWriteLock</span><span class="o">)(</span><span class="n">body</span><span class="o">)</span>

  <span class="k">protected</span> <span class="k">def</span> <span class="n">synchronizeOperation</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">L</span> <span class="k">&lt;:</span> <span class="kt">TypedLock</span><span class="o">](</span><span class="n">lock</span><span class="k">:</span> <span class="kt">L</span><span class="o">)(</span><span class="n">body</span><span class="k">:</span> <span class="kt">L</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">lock</span><span class="o">.</span><span class="n">lock</span><span class="o">()</span>
    <span class="k">try</span> <span class="o">{</span> <span class="n">body</span><span class="o">(</span><span class="n">lock</span><span class="o">)</span> <span class="o">}</span>
    <span class="k">finally</span> <span class="o">{</span> <span class="n">lock</span><span class="o">.</span><span class="n">unlock</span><span class="o">()</span> <span class="o">}</span>
  <span class="o">}</span>

<span class="o">}</span>

<span class="k">object</span> <span class="nc">SynchronizedAccess</span> <span class="o">{</span>

  <span class="k">sealed</span> <span class="k">trait</span> <span class="nc">TypedLock</span> <span class="o">{</span>

    <span class="k">protected</span> <span class="k">val</span> <span class="n">instance</span><span class="k">:</span> <span class="kt">Lock</span>

    <span class="k">def</span> <span class="n">lock</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">lock</span><span class="o">()</span>

    <span class="k">def</span> <span class="n">unlock</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">unlock</span><span class="o">()</span>

    <span class="k">def</span> <span class="n">tryLock</span><span class="o">()</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">tryLock</span><span class="o">()</span>

  <span class="o">}</span>

  <span class="k">sealed</span> <span class="k">class</span> <span class="nc">ReadLock</span><span class="o">(</span><span class="n">readLock</span><span class="k">:</span> <span class="kt">ReentrantReadWriteLock.ReadLock</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">TypedLock</span> <span class="o">{</span>

    <span class="k">override</span> <span class="k">protected</span> <span class="k">val</span> <span class="n">instance</span><span class="k">:</span> <span class="kt">Lock</span> <span class="o">=</span> <span class="n">readLock</span>

  <span class="o">}</span>

  <span class="k">sealed</span> <span class="k">class</span> <span class="nc">ReadWriteLock</span>
  <span class="o">(</span><span class="n">readLock</span><span class="k">:</span> <span class="kt">ReentrantReadWriteLock.ReadLock</span><span class="o">,</span>
   <span class="n">writeLock</span><span class="k">:</span> <span class="kt">ReentrantReadWriteLock.WriteLock</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">ReadLock</span><span class="o">(</span><span class="n">readLock</span><span class="o">)</span> <span class="o">{</span>

    <span class="k">override</span> <span class="k">protected</span> <span class="k">val</span> <span class="n">instance</span><span class="k">:</span> <span class="kt">Lock</span> <span class="o">=</span> <span class="n">writeLock</span>

  <span class="o">}</span>

<span class="o">}</span></code></pre>

<p>Looks complicated? See me while I dance with it:</p>

<pre><code class="language-scala"><span class="k">class</span> <span class="nc">UserService</span> <span class="k">extends</span> <span class="nc">SynchronizedAccess</span> <span class="o">{</span>

  <span class="k">private</span> <span class="k">val</span> <span class="n">users</span><span class="k">:</span> <span class="kt">Synchronized</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">User</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Synchronized</span><span class="o">(</span><span class="nc">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">User</span><span class="o">]())</span>

  <span class="k">private</span> <span class="k">val</span> <span class="n">managerCount</span><span class="k">:</span> <span class="kt">Synchronized</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Synchronized</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">save</span><span class="o">(</span><span class="n">user</span><span class="k">:</span> <span class="kt">User</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="c1">// Note that `users` and `managerCount` variables will be updated</span>
    <span class="c1">// atomically while the rest waits for the `ReadWrite` lock.</span>
    <span class="n">synchronizeReadWrite</span> <span class="o">{</span> <span class="k">implicit</span> <span class="n">lock</span> <span class="k">=&gt;</span>
      <span class="n">users</span><span class="o">()</span> <span class="o">+=</span> <span class="n">user</span><span class="o">.</span><span class="n">id</span> <span class="o">-&gt;</span> <span class="n">user</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="n">manager</span><span class="o">)</span>
        <span class="n">managerCount</span><span class="o">()</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="o">}</span>

  <span class="k">def</span> <span class="n">findById</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">User</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">synchronizeRead</span> <span class="o">{</span> <span class="k">implicit</span> <span class="n">lock</span> <span class="k">=&gt;</span>
      <span class="n">users</span><span class="o">().</span><span class="n">get</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>
    <span class="o">}</span>

  <span class="k">def</span> <span class="n">findAllNames</span><span class="o">()</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">synchronizeRead</span> <span class="o">{</span> <span class="k">implicit</span> <span class="n">lock</span> <span class="k">=&gt;</span>
      <span class="n">findAll</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">name</span><span class="o">)</span>
    <span class="o">}</span>

  <span class="c1">// Note that findAll() requires a `ReadLock` context in order to access `users`.</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">findAll</span><span class="o">(</span><span class="k">implicit</span> <span class="n">lock</span><span class="k">:</span> <span class="kt">ReadLock</span><span class="o">)</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">User</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">users</span><span class="o">().</span><span class="n">values</span><span class="o">.</span><span class="n">toSeq</span>

  <span class="k">def</span> <span class="n">findManagerCount</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> 
    <span class="n">synchronizeRead</span> <span class="o">{</span> <span class="k">implicit</span> <span class="n">lock</span> <span class="k">=&gt;</span>
      <span class="n">managerCount</span><span class="o">()</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre>

<p>In a nutshell, what did <code>SynchronizedAccess</code> trait really bring us? <em>It
enforces a <strong>typed</strong> and <strong>unique</strong> locking context on the variables of type
<code>Synchronized[T]</code>.</em> It is <em>typed</em> because read and read-write operations are
distinct from each other in the function decleration via implicit <code>ReadLock</code>
and <code>ReadWriteLock</code> parameters. It is <em>unique</em> because <code>Synchronized</code>
variables can only be accessed by the instance lock inherited from
<code>SynchronizedAccess</code> trait.</p>

<p>Here is your free lunch. <a href="https://translate.google.com/#nl/en/eet%20smakelijk">Eet smaaklijk!</a></p>

<h1 id="common-confusions">Common Confusions</h1>

<p>I sadly observed that there are some common confusions about <code>Synchronized[T]</code>
type. Let me try to address them here.</p>

<ul>
  <li>
    <p><strong>I could have used a <code>ConcurrentMap</code> instead!</strong> <code>Map</code> usage in the examples
above is just there for demonstration purposes. It does not have to be a
collection at all. If you have just one variable and it is a collection,
then going with a synchronized/concurrent implementation is totally fine.</p>
  </li>
  <li>
    <p><strong>I could have used a <code>ConcurrentMap</code> and an <code>AtomicInteger</code> instead!</strong> No,
you cannot. Then you would totally spoil the <em>atomic</em> read-write operations.
You will still need a <em>transaction</em>-like mechanism ala in SQL.</p>
  </li>
</ul>


	  <script type="text/javascript">
	    $("#post table").attr("class", "table table-hover");
	  </script>

	  <div id="disqus_thread"></div>
	  <script type="text/javascript">
	  var disqus_shortname = 'vyazici';
	  var disqus_identifier = '/blog/post/20150909-enforce-locking/';
	  var disqus_title = 'Enforcing a Locking Context on Variables in Scala';
	  (function() {
	  	var dsq = document.createElement('script');
	  	dsq.type = 'text/javascript';
	  	dsq.async = true;
	  	dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
	  	(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	  })();
	  </script>

	</div>

</div>





    </div>
  </body>
</html>

