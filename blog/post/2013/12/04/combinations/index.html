<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Key to Parallel Combinations: Enumeration</title>
    <link rel="stylesheet" href="/css/common.css">
    <meta name="generator" content="nanoc 3.8.0">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/css/post.css">
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-40183531-1']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>
  <body>
    <div id="container">

      <ul id="menu">
        <li><a href="/">Home</a></li><li><a href="/blog/">Blog</a></li><li><a href="/code/">Code</a></li><li><a href="/blog/feed/">Feed</a></li>
      </ul>

    

<div id="post">

    <div class="head">
        <div class="title">Key to Parallel Combinations: Enumeration</div>
        <div class="subtitle">posted at
            December 4, 2013
            with tags <a href="/blog/tag/algorithm">algorithm</a>, <a href="/blog/tag/concurrency">concurrency</a>, <a href="/blog/tag/java">java</a>
        </div>
    </div>

    <div class="body">

        <script type="text/javascript">
        var asyncLoadRequests = [];
        </script>

        
<p>Combinations have many use cases in the daily life of a programmer: for
testing a given function, for generating the all possible input sets of a
particular problem instance, etc. Writing them down in lexicographic order is
something we all do time to time. For instance, 2-combination of a set
<script type="math/tex">(0, 1, 2, 3)</script> can simply be written as follows.</p>

<script type="math/tex; mode=display">{(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)}</script>

<p>We also have a shortcut to get the total number of combinations for a particular
instance. That is,</p>

<script type="math/tex; mode=display">{n \choose r} = \frac{n(n-1)\ldots(n-r+1)}{r(r-1)\dots1}=\frac{n!}{r!(n-r)!},</script>

<p>which applies to our above example 4-choose-2 as follows:
<script type="math/tex">{4 \choose 2} = \frac{4 \times 3}{2} = 6</script>.</p>

<p>You might also have noticed the pattern we used to generate the combinations in
lexicographic order. The algorithm finds the rightmost index element that can be
incremented, increments it, and then changes the elements to the right to each
be 1 plus the element on their left. This procedure repeats until there are no
more rooms left to increment. (You might want to check out <a href="http://eu.wiley.com/WileyCDA/WileyTitle/productCd-%0AEHEP001993.html">Applied
Combinatorics</a> by Alan Tucker for further details of the algorithm.)</p>

<p>One advantage of generating combinations in lexicographic order using the above
algorithm is that given the <script type="math/tex">k</script>‘th combination, one can easily generate
<script type="math/tex">k+1</script>‘th combination. Which leads us to the fact that one can continue
generating combinations given the combination at a particular position.</p>

<h1 id="the-problem">The Problem</h1>

<p>In the case of a single consumer, one can iterate over a set of combinations
step by step. However, what if there are multiple consumers? In this case, a
single producer can present a central combination queue, where it pushes new
combinations on demand, and then the consumers can poll the queue as they
desire. That being said, in this setup the producer can become the bottleneck.
That is, what if consumers poll the queue at a speed faster than the producer’s
push rate? Houston, we have a problem.</p>

<p>Previously we have seen that given the <script type="math/tex">k</script>‘th combination, we can compute the
<script type="math/tex">k+1</script>‘th one. In addition, we also know how to calculate the total number of
combinations, that is, <script type="math/tex">{n \choose r}</script>. With this in mind, we can split the
all possible combinations set <script type="math/tex">\{c_1, c_2, \dots\}</script> into two separate parts:</p>

<script type="math/tex; mode=display">\{c_1, \dots, c_m\} \textrm{ and } \{c_{m+1}, \dots, c_l\}, \\
\textrm{where } l = {n \choose r} \textrm{ and } m = \lfloor ^l/_2 \rfloor.</script>

<p>Going from <script type="math/tex">c_1</script> to <script type="math/tex">c_m</script> is trivial, we can keep a counter for the
generated combinations up to <script type="math/tex">m</script>. But what about <script type="math/tex">c_{m+1}</script>? How can we
compute the <script type="math/tex">{m+1}</script>‘th combination without having a prior information about
<script type="math/tex">m</script>‘th one. In other words, can we calculate <script type="math/tex">c_{m+1}</script>, given just <script type="math/tex">n</script> and
<script type="math/tex">r</script>?</p>

<h1 id="enumerating-combinations">Enumerating Combinations</h1>

<p>Lucky for us, there exists a vast literature for <a href="http://en.wikipedia.org/wiki/Combinatorial_number_system">combinatorial number
system</a>, where people
come up with a way to enumerate combinations. Long story short, combinatorial
number system presents a mapping between natural numbers (taken to include 0)
and the combinations. In a combinatorial number system of degree <script type="math/tex">r</script>, each
natural number <script type="math/tex">b\in\mathbb{N}</script> map to a one and only one r-combination
<script type="math/tex">[d_1, d_2, \dots, d_r]</script> with the following equality.</p>

<script type="math/tex; mode=display">b = {d_1 \choose r} + {d_2 \choose r-1} + \dots + {d_r \choose 1},\\
\textrm{ where } d_1 > d_2 > \dots > d_r.</script>

<p>For instance, let <script type="math/tex">b=8</script> and <script type="math/tex">r=2</script>. Here <script type="math/tex">b</script> corresponds to the
2-combination <script type="math/tex">[4, 2]</script> in combinatorial number system of degree 2 with the
following equality.</p>

<script type="math/tex; mode=display">8 = {4 \choose 2} + {2 \choose 1}</script>

<p>The r-combination of a given number <script type="math/tex">b</script> can be computed using the following
greedy algorithm: take <script type="math/tex">d_i</script> maximal with <script type="math/tex">{d_i \choose i} \leq b</script>, then
take <script type="math/tex">d_{i-1}</script> maximal with <script type="math/tex">{d_{i-1} \choose i-1} \leq b - {d_i \choose i}</script>,
and so forth.</p>

<p>So far so good. Let’s do the magic. Suppose that we want to enumerate the
combinations of 5-choose-2. That is, we want the following mapping.</p>

<script type="math/tex; mode=display">0 \rightarrow [0, 1] \quad 5 \rightarrow [1, 3] \\
1 \rightarrow [0, 2] \quad 6 \rightarrow [1, 4] \\
2 \rightarrow [0, 3] \quad 7 \rightarrow [2, 3] \\
3 \rightarrow [0, 4] \quad 8 \rightarrow [2, 4] \\
4 \rightarrow [1, 2] \quad 9 \rightarrow [3, 4]</script>

<p>We know that <script type="math/tex">{5 \choose 2} = 10</script>, hence we have 10 combinations enumerated
from 0 to 9. Let’s try to find the 3rd combination in this sequence from
scratch.</p>

<ol>
  <li>First, we set <script type="math/tex">i</script> to the index of the combination we are interested in: <script type="math/tex">i=3</script>
</li>
  <li>Second, we set <script type="math/tex">j</script> to the dual index of <script type="math/tex">i</script> in <script type="math/tex">{5 \choose 2}</script> system:
<script type="math/tex">j = {5 \choose 2} - i - 1 = 6</script>.</li>
  <li>Now let’s find the 2-combination of <script type="math/tex">j</script>: <script type="math/tex">6 = {4 \choose 2} + {0 \choose 1}</script>,
that is, the 2-combination corresponding to <script type="math/tex">j=6</script> is <script type="math/tex">[4, 0]</script>.</li>
  <li>Next we subtract the found 2-combination from the mask <script type="math/tex">[4, 4]</script>, where 4’s
comes from <script type="math/tex">5-1</script>: <script type="math/tex">[4, 4] - [4, 0] = [0, 4]</script>.</li>
</ol>

<p>Yay! 3rd combination of <script type="math/tex">{5 \choose 2}</script> system is <script type="math/tex">[0, 4]</script>! Hrm… Was that
a coincidence? Let’s give it another try with 8th combination this time.</p>

<ol>
  <li>First, we set <script type="math/tex">i</script> to the index of the combination we are interested in: <script type="math/tex">i=8</script>
</li>
  <li>Second, we set <script type="math/tex">j</script> to the dual index of <script type="math/tex">i</script> in <script type="math/tex">{5 \choose 2}</script> system:
<script type="math/tex">j = {5 \choose 2} - i - 1 = 1</script>.</li>
  <li>Now let’s find the 2-combination of <script type="math/tex">j</script>: <script type="math/tex">1 = {2 \choose 2} + {0 \choose 1}</script>,
that is, the 2-combination corresponding to <script type="math/tex">j=1</script> is <script type="math/tex">[2, 0]</script>.</li>
  <li>Next we subtract the found 2-combination from the mask <script type="math/tex">[4, 4]</script>:
<script type="math/tex">[4, 4] - [2, 0] = [2, 4]</script>.</li>
</ol>

<p>8th combination turns out to be <script type="math/tex">[2, 4]</script>. Eureka!</p>

<h1 id="conclusion">Conclusion</h1>

<p>We have shown that using <script type="math/tex">r</script>-combinations one can compute the <script type="math/tex">k</script>‘th
combination among the lexicographically ordered set of combinations of
<script type="math/tex">n</script>-choose-<script type="math/tex">r</script>, where <script type="math/tex">0 \leq k \lt {n \choose r}</script>. Using this method we
can partition the space of all combinations into multiple subsets and generate
each of them individually. For this purpose, I put together a Java library:
<a href="https://github.com/vy/combination">combination</a>. Here is a sample snippet.</p>

<pre><code class="language-java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Combination</span> <span class="n">c52</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Combination</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
        <span class="kt">long</span> <span class="n">l</span> <span class="o">=</span> <span class="n">c52</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
        <span class="n">println</span><span class="o">(</span><span class="s">"size(c52): %d"</span><span class="o">,</span> <span class="n">l</span><span class="o">);</span>
        <span class="n">println</span><span class="o">(</span><span class="s">"c52"</span><span class="o">,</span> <span class="o">(</span><span class="n">CombinationIterator</span><span class="o">)</span> <span class="n">c52</span><span class="o">.</span><span class="na">iterator</span><span class="o">());</span>
        <span class="cm">/*</span>
<span class="cm">         * size(c52): 10</span>
<span class="cm">         * c52:</span>
<span class="cm">         * -&gt; [0, 1]</span>
<span class="cm">         * -&gt; [0, 2]</span>
<span class="cm">         * -&gt; [0, 3]</span>
<span class="cm">         * -&gt; [0, 4]</span>
<span class="cm">         * -&gt; [1, 2]</span>
<span class="cm">         * -&gt; [1, 3]</span>
<span class="cm">         * -&gt; [1, 4]</span>
<span class="cm">         * -&gt; [2, 3]</span>
<span class="cm">         * -&gt; [2, 4]</span>
<span class="cm">         * -&gt; [3, 4]</span>
<span class="cm">         */</span>

        <span class="kt">long</span> <span class="n">m</span> <span class="o">=</span> <span class="n">l</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="n">CombinationIterator</span> <span class="n">c52_lhs</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">CombinationIterator</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">m</span><span class="o">);</span>
        <span class="n">CombinationIterator</span> <span class="n">c52_rhs</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">CombinationIterator</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>

        <span class="n">println</span><span class="o">(</span><span class="s">"c52_lhs"</span><span class="o">,</span> <span class="n">c52_lhs</span><span class="o">);</span>
        <span class="cm">/*</span>
<span class="cm">         * c52_lhs:</span>
<span class="cm">         * -&gt; [0, 1]</span>
<span class="cm">         * -&gt; [0, 2]</span>
<span class="cm">         * -&gt; [0, 3]</span>
<span class="cm">         * -&gt; [0, 4]</span>
<span class="cm">         * -&gt; [1, 2]</span>
<span class="cm">         */</span>

        <span class="n">println</span><span class="o">(</span><span class="s">"c52_rhs"</span><span class="o">,</span> <span class="n">c52_rhs</span><span class="o">);</span>
        <span class="cm">/*</span>
<span class="cm">         * c52_rhs:</span>
<span class="cm">         * -&gt; [2, 3]</span>
<span class="cm">         * -&gt; [2, 4]</span>
<span class="cm">         * -&gt; [3, 4]</span>
<span class="cm">         * -&gt; [3, 4]</span>
<span class="cm">         */</span>

        <span class="n">println</span><span class="o">(</span><span class="s">"5C2: %d"</span><span class="o">,</span> <span class="n">Combination</span><span class="o">.</span><span class="na">choose</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">));</span>
        <span class="cm">/*</span>
<span class="cm">         * 5C2: 10</span>
<span class="cm">         */</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="n">Combination</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="n">c</span><span class="o">);</span>
        <span class="n">println</span><span class="o">(</span><span class="s">"3rd combination of 5C2: %s"</span><span class="o">,</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">c</span><span class="o">));</span>
        <span class="cm">/*</span>
<span class="cm">         * 3rd combination of 5C2: [0, 4]</span>
<span class="cm">         */</span>

        <span class="n">Combination</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="n">c</span><span class="o">);</span>
        <span class="n">println</span><span class="o">(</span><span class="s">"8th combination of 5C2: %s"</span><span class="o">,</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">c</span><span class="o">));</span>
        <span class="cm">/*</span>
<span class="cm">         * 8th combination of 5C2: [2, 4]</span>
<span class="cm">         */</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">println</span><span class="o">(</span><span class="n">String</span> <span class="n">fmt</span><span class="o">,</span> <span class="n">Object</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">fmt</span><span class="o">,</span> <span class="n">args</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">println</span><span class="o">(</span><span class="n">String</span> <span class="n">caption</span><span class="o">,</span> <span class="n">CombinationIterator</span> <span class="n">ci</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">println</span><span class="o">(</span><span class="s">"%s:"</span><span class="o">,</span> <span class="n">caption</span><span class="o">);</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">ci</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span>
            <span class="n">println</span><span class="o">(</span><span class="s">"-&gt; %s"</span><span class="o">,</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">ci</span><span class="o">.</span><span class="na">next</span><span class="o">()));</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre>

<h1 id="references">References</h1>

<p>I started my pursuit with Wikipedia page of <a href="http://en.wikipedia.org/wiki/Combinatorial_number_system">combinatorial number
system</a>. In the
beginning it did not make much sense. Later I found the enlightening 2004 post
<a href="http://msdn.microsoft.com/en-us/library/aa289166%28VS.71%29.aspx">Generating the mth Lexicographical Element of a Mathematical
Combination</a>
by James McCaffrey, which cleared out the things and made me start to understand
the Wikipedia page.</p>


        

        
        <script type="text/javascript"
          src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        

        

        

        

        

    </div>
  </body>
</html>


        <script type="text/javascript">
        for (var i = 0; i < asyncLoadRequests.length; i++) {
            asyncLoadRequest = asyncLoadRequests[i];
            asyncLoadRequest();
        }
        </script>

    </div>

</div>
